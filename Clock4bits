`include "constants.vams"
`include "disciplines.vams"



module counter_NAND_tb (A, B, CLK, VDD, VSS);
  output A, B;   electrical A, B;
  input  CLK;    electrical CLK;
  input  VDD, VSS; electrical VDD, VSS;

  // Par?metros temporales
  parameter real tr   = 1p;   // transici?n de salida
  parameter real tdA  = 0;    // skew opcional en A
  parameter real tdB  = 0;    // skew opcional en B
  parameter real vtol = 1m;
  parameter real ttol = 1p;

  // Estado interno
  integer phase;        // 0..7 (0..3 Gray, 4..7 binario)
  integer a_bit, b_bit; // A=MSB, B=LSB
  integer idx;          // auxiliar para binario
  real a_tgt, b_tgt;    // valores objetivo (en volt)
  real Vth;             // umbral din?mico

  analog begin
    $bound_step(tr/20);

    // Umbral din?mico: mitad de VDD?VSS
    Vth = V(VDD, VSS)/2.0;

    // ===== Inicial =====
    @(initial_step) begin
      phase = 0;
      a_bit = 0; b_bit = 0;
      a_tgt = V(VSS);   // 0 V
      b_tgt = V(VSS);
    end

    // Contribuciones continuas
    V(A) <+ transition(a_tgt, tdA, tr);
    V(B) <+ transition(b_tgt, tdB, tr);

    // ===== Flanco de reloj =====
    @(cross(V(CLK, VSS) - Vth, +1, ttol, vtol)) begin
      phase = phase + 1;
      if (phase > 7) phase = 0;

      if (phase < 4) begin
        // ---- 4 pasos Gray ----
        case (phase)
          0: begin a_bit = 0; b_bit = 0; end
          1: begin a_bit = 0; b_bit = 1; end
          2: begin a_bit = 1; b_bit = 1; end
          3: begin a_bit = 1; b_bit = 0; end
          default: begin a_bit = 0; b_bit = 0; end
        endcase
      end else begin
        // ---- 4 pasos binarios ----
        idx = phase - 4;
        a_bit = (idx >> 1) & 1;
        b_bit = (idx     ) & 1;
      end

      // Actualiza los objetivos usando niveles reales de VDD/VSS
      if (a_bit != 0)
        a_tgt = V(VDD);
      else
        a_tgt = V(VSS);

      if (b_bit != 0)
        b_tgt = V(VDD);
      else
        b_tgt = V(VSS);
    end
  end
endmodule
